/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.17.9.0 (NJsonSchema v9.10.46.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { BaseClient } from './api.client.base'
import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { Http, Headers, ResponseContentType, Response, RequestOptionsArgs } from '@angular/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class Client extends BaseClient {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @model (optional) 
     * @return Success
     */
    contact(model: MessageModel): Observable<void> {
        let url_ = this.baseUrl + "/Contact/Contact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processContact(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processContact(<any>r));
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processContact(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    markAsRead(id: number): Observable<void> {
        let url_ = this.baseUrl + "/Contact/MarkAsRead/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processMarkAsRead(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processMarkAsRead(<any>r));
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processMarkAsRead(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    markAsUnread(id: number): Observable<void> {
        let url_ = this.baseUrl + "/Contact/MarkAsUnread/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processMarkAsUnread(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processMarkAsUnread(<any>r));
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processMarkAsUnread(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllMessages(): Observable<MessageReadModel[]> {
        let url_ = this.baseUrl + "/Contact/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllMessages(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllMessages(<any>r));
                } catch (e) {
                    return <Observable<MessageReadModel[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<MessageReadModel[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAllMessages(response: Response): Observable<MessageReadModel[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MessageReadModel.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<MessageReadModel[]>(<any>null);
    }

    /**
     * @displayProperties_Title (optional) 
     * @displayProperties_SortOrder (optional) 
     * @displayProperties_PhotoGroupId (optional) 
     * @fileFormData (optional) 
     * @return Success
     */
    createPhoto(displayProperties_Title: string, displayProperties_SortOrder: number, displayProperties_PhotoGroupId: number, fileFormData: FileParameter): Observable<number> {
        let url_ = this.baseUrl + "/Photo/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (displayProperties_Title !== null && displayProperties_Title !== undefined)
            content_.append("DisplayProperties.Title", displayProperties_Title.toString());
        if (displayProperties_SortOrder !== null && displayProperties_SortOrder !== undefined)
            content_.append("DisplayProperties.SortOrder", displayProperties_SortOrder.toString());
        if (displayProperties_PhotoGroupId !== null && displayProperties_PhotoGroupId !== undefined)
            content_.append("DisplayProperties.PhotoGroupId", displayProperties_PhotoGroupId.toString());
        if (fileFormData !== null && fileFormData !== undefined)
            content_.append("File", fileFormData.data, fileFormData.fileName ? fileFormData.fileName : "File");

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processCreatePhoto(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processCreatePhoto(<any>r));
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processCreatePhoto(response: Response): Observable<number> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<number>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    updatePhoto(model: PhotoDisplayPropertiesDetailModel): Observable<void> {
        let url_ = this.baseUrl + "/Photo/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processUpdatePhoto(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUpdatePhoto(<any>r));
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdatePhoto(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    deletePhoto(id: number): Observable<void> {
        let url_ = this.baseUrl + "/Photo/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processDeletePhoto(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDeletePhoto(<any>r));
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeletePhoto(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPhotos(): Observable<PhotoDisplayPropertiesDetailModel[]> {
        let url_ = this.baseUrl + "/Photo/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllPhotos(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllPhotos(<any>r));
                } catch (e) {
                    return <Observable<PhotoDisplayPropertiesDetailModel[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<PhotoDisplayPropertiesDetailModel[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAllPhotos(response: Response): Observable<PhotoDisplayPropertiesDetailModel[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PhotoDisplayPropertiesDetailModel.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PhotoDisplayPropertiesDetailModel[]>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    createPhotoGroup(model: PhotoGroupCreateModel): Observable<number> {
        let url_ = this.baseUrl + "/PhotoGroup/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processCreatePhotoGroup(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processCreatePhotoGroup(<any>r));
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processCreatePhotoGroup(response: Response): Observable<number> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<number>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    updatePhotoGroup(model: PhotoGroupModel): Observable<void> {
        let url_ = this.baseUrl + "/PhotoGroup/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processUpdatePhotoGroup(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUpdatePhotoGroup(<any>r));
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdatePhotoGroup(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    deletePhotoGroup(id: number): Observable<void> {
        let url_ = this.baseUrl + "/PhotoGroup/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processDeletePhotoGroup(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDeletePhotoGroup(<any>r));
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeletePhotoGroup(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPhotoGroups(): Observable<PhotoGroupModel[]> {
        let url_ = this.baseUrl + "/PhotoGroup/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllPhotoGroups(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllPhotoGroups(<any>r));
                } catch (e) {
                    return <Observable<PhotoGroupModel[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<PhotoGroupModel[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAllPhotoGroups(response: Response): Observable<PhotoGroupModel[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PhotoGroupModel.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PhotoGroupModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getPhotoGroup(id: number): Observable<PhotoGroupModel> {
        let url_ = this.baseUrl + "/PhotoGroup/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetPhotoGroup(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetPhotoGroup(<any>r));
                } catch (e) {
                    return <Observable<PhotoGroupModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<PhotoGroupModel>><any>Observable.throw(response_);
        });
    }

    protected processGetPhotoGroup(response: Response): Observable<PhotoGroupModel> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PhotoGroupModel.fromJS(resultData200) : new PhotoGroupModel();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PhotoGroupModel>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    register(model: RegisterModel): Observable<void> {
        let url_ = this.baseUrl + "/Registration/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processRegister(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processRegister(<any>r));
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processRegister(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    deleteRegistration(id: number): Observable<void> {
        let url_ = this.baseUrl + "/Registration/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processDeleteRegistration(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDeleteRegistration(<any>r));
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteRegistration(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllParents(): Observable<RegisteredParentModel[]> {
        let url_ = this.baseUrl + "/Registration/GetAllParents";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllParents(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllParents(<any>r));
                } catch (e) {
                    return <Observable<RegisteredParentModel[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<RegisteredParentModel[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAllParents(response: Response): Observable<RegisteredParentModel[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(RegisteredParentModel.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RegisteredParentModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllChildren(): Observable<RegisteredChildModel[]> {
        let url_ = this.baseUrl + "/Registration/GetAllChildren";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllChildren(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllChildren(<any>r));
                } catch (e) {
                    return <Observable<RegisteredChildModel[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<RegisteredChildModel[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAllChildren(response: Response): Observable<RegisteredChildModel[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(RegisteredChildModel.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RegisteredChildModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllParentsCsv(): Observable<void> {
        let url_ = this.baseUrl + "/Registration/GetAllParents/Csv";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllParentsCsv(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllParentsCsv(<any>r));
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processGetAllParentsCsv(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllChildrenCsv(): Observable<void> {
        let url_ = this.baseUrl + "/Registration/GetAllChildren/Csv";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllChildrenCsv(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllChildrenCsv(<any>r));
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processGetAllChildrenCsv(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    createEvent(model: EventCreateModel): Observable<number> {
        let url_ = this.baseUrl + "/Schedule/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processCreateEvent(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processCreateEvent(<any>r));
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processCreateEvent(response: Response): Observable<number> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<number>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    updateEvent(model: EventModel): Observable<void> {
        let url_ = this.baseUrl + "/Schedule/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processUpdateEvent(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUpdateEvent(<any>r));
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateEvent(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    deleteEvent(id: number): Observable<void> {
        let url_ = this.baseUrl + "/Schedule/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processDeleteEvent(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDeleteEvent(<any>r));
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteEvent(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllEvents(): Observable<EventModel[]> {
        let url_ = this.baseUrl + "/Schedule/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllEvents(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllEvents(<any>r));
                } catch (e) {
                    return <Observable<EventModel[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<EventModel[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAllEvents(response: Response): Observable<EventModel[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EventModel.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<EventModel[]>(<any>null);
    }

    /**
     * @until (optional) 
     * @return Success
     */
    getEvents(until: Date): Observable<EventModel[]> {
        let url_ = this.baseUrl + "/Schedule/Get?";
        if (until !== undefined)
            url_ += "until=" + encodeURIComponent(until ? "" + until.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request(url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetEvents(<any>r));
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetEvents(<any>r));
                } catch (e) {
                    return <Observable<EventModel[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<EventModel[]>><any>Observable.throw(response_);
        });
    }

    protected processGetEvents(response: Response): Observable<EventModel[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EventModel.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<EventModel[]>(<any>null);
    }
}

export class MessageModel implements IMessageModel {
    firstName?: string;
    lastName?: string;
    email?: string;
    body?: string;

    constructor(data?: IMessageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.body = data["body"];
        }
    }

    static fromJS(data: any): MessageModel {
        data = typeof data === 'object' ? data : {};
        let result = new MessageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["body"] = this.body;
        return data; 
    }
}

export interface IMessageModel {
    firstName?: string;
    lastName?: string;
    email?: string;
    body?: string;
}

export class MessageReadModel implements IMessageReadModel {
    id: number;
    timestamp: Date;
    isRead: boolean;
    firstName?: string;
    lastName?: string;
    email?: string;
    body?: string;

    constructor(data?: IMessageReadModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.timestamp = data["timestamp"] ? new Date(data["timestamp"].toString()) : <any>undefined;
            this.isRead = data["isRead"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.body = data["body"];
        }
    }

    static fromJS(data: any): MessageReadModel {
        data = typeof data === 'object' ? data : {};
        let result = new MessageReadModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["isRead"] = this.isRead;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["body"] = this.body;
        return data; 
    }
}

export interface IMessageReadModel {
    id: number;
    timestamp: Date;
    isRead: boolean;
    firstName?: string;
    lastName?: string;
    email?: string;
    body?: string;
}

export class PhotoDisplayPropertiesDetailModel implements IPhotoDisplayPropertiesDetailModel {
    photoId: number;
    title?: string;
    sortOrder: number;
    photoGroupId: number;

    constructor(data?: IPhotoDisplayPropertiesDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.photoId = data["photoId"];
            this.title = data["title"];
            this.sortOrder = data["sortOrder"];
            this.photoGroupId = data["photoGroupId"];
        }
    }

    static fromJS(data: any): PhotoDisplayPropertiesDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new PhotoDisplayPropertiesDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["photoId"] = this.photoId;
        data["title"] = this.title;
        data["sortOrder"] = this.sortOrder;
        data["photoGroupId"] = this.photoGroupId;
        return data; 
    }
}

export interface IPhotoDisplayPropertiesDetailModel {
    photoId: number;
    title?: string;
    sortOrder: number;
    photoGroupId: number;
}

export class PhotoGroupCreateModel implements IPhotoGroupCreateModel {
    name?: string;
    sortOrder: number;

    constructor(data?: IPhotoGroupCreateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): PhotoGroupCreateModel {
        data = typeof data === 'object' ? data : {};
        let result = new PhotoGroupCreateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface IPhotoGroupCreateModel {
    name?: string;
    sortOrder: number;
}

export class PhotoGroupModel implements IPhotoGroupModel {
    id: number;
    name?: string;
    sortOrder: number;

    constructor(data?: IPhotoGroupModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): PhotoGroupModel {
        data = typeof data === 'object' ? data : {};
        let result = new PhotoGroupModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface IPhotoGroupModel {
    id: number;
    name?: string;
    sortOrder: number;
}

export class RegisterModel implements IRegisterModel {
    contactInformation?: RegisterContactInformationModel;
    parent?: RegisterParentModel;
    children?: RegisterChildModel[];

    constructor(data?: IRegisterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactInformation = data["contactInformation"] ? RegisterContactInformationModel.fromJS(data["contactInformation"]) : <any>undefined;
            this.parent = data["parent"] ? RegisterParentModel.fromJS(data["parent"]) : <any>undefined;
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [];
                for (let item of data["children"])
                    this.children.push(RegisterChildModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RegisterModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactInformation"] = this.contactInformation ? this.contactInformation.toJSON() : <any>undefined;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRegisterModel {
    contactInformation?: RegisterContactInformationModel;
    parent?: RegisterParentModel;
    children?: RegisterChildModel[];
}

export class RegisterContactInformationModel implements IRegisterContactInformationModel {
    email?: string;
    phoneNumber?: string;
    address?: string;
    address2?: string;
    city?: string;
    state?: string;
    zip?: string;

    constructor(data?: IRegisterContactInformationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
            this.phoneNumber = data["phoneNumber"];
            this.address = data["address"];
            this.address2 = data["address2"];
            this.city = data["city"];
            this.state = data["state"];
            this.zip = data["zip"];
        }
    }

    static fromJS(data: any): RegisterContactInformationModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterContactInformationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        data["address2"] = this.address2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zip"] = this.zip;
        return data; 
    }
}

export interface IRegisterContactInformationModel {
    email?: string;
    phoneNumber?: string;
    address?: string;
    address2?: string;
    city?: string;
    state?: string;
    zip?: string;
}

export class RegisterParentModel implements IRegisterParentModel {
    firstName?: string;
    lastName?: string;

    constructor(data?: IRegisterParentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
        }
    }

    static fromJS(data: any): RegisterParentModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterParentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data; 
    }
}

export interface IRegisterParentModel {
    firstName?: string;
    lastName?: string;
}

export class RegisterChildModel implements IRegisterChildModel {
    firstName?: string;
    lastName?: string;
    gender: RegisterChildModelGender;
    dateOfBirth: Date;
    shirtSize?: string;

    constructor(data?: IRegisterChildModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.gender = data["gender"];
            this.dateOfBirth = data["dateOfBirth"] ? new Date(data["dateOfBirth"].toString()) : <any>undefined;
            this.shirtSize = data["shirtSize"];
        }
    }

    static fromJS(data: any): RegisterChildModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterChildModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["gender"] = this.gender;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["shirtSize"] = this.shirtSize;
        return data; 
    }
}

export interface IRegisterChildModel {
    firstName?: string;
    lastName?: string;
    gender: RegisterChildModelGender;
    dateOfBirth: Date;
    shirtSize?: string;
}

export class RegisteredParentModel implements IRegisteredParentModel {
    registrationId: number;
    firstName?: string;
    lastName?: string;
    email?: string;
    childCount: number;

    constructor(data?: IRegisteredParentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.registrationId = data["registrationId"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.childCount = data["childCount"];
        }
    }

    static fromJS(data: any): RegisteredParentModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisteredParentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registrationId"] = this.registrationId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["childCount"] = this.childCount;
        return data; 
    }
}

export interface IRegisteredParentModel {
    registrationId: number;
    firstName?: string;
    lastName?: string;
    email?: string;
    childCount: number;
}

export class RegisteredChildModel implements IRegisteredChildModel {
    parentFirstName?: string;
    parentLastName?: string;
    firstName?: string;
    lastName?: string;
    gender: RegisteredChildModelGender;
    emailAddress?: string;
    dateOfBirth: Date;
    shirtSize?: string;

    constructor(data?: IRegisteredChildModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentFirstName = data["parentFirstName"];
            this.parentLastName = data["parentLastName"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.gender = data["gender"];
            this.emailAddress = data["emailAddress"];
            this.dateOfBirth = data["dateOfBirth"] ? new Date(data["dateOfBirth"].toString()) : <any>undefined;
            this.shirtSize = data["shirtSize"];
        }
    }

    static fromJS(data: any): RegisteredChildModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisteredChildModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentFirstName"] = this.parentFirstName;
        data["parentLastName"] = this.parentLastName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["gender"] = this.gender;
        data["emailAddress"] = this.emailAddress;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["shirtSize"] = this.shirtSize;
        return data; 
    }
}

export interface IRegisteredChildModel {
    parentFirstName?: string;
    parentLastName?: string;
    firstName?: string;
    lastName?: string;
    gender: RegisteredChildModelGender;
    emailAddress?: string;
    dateOfBirth: Date;
    shirtSize?: string;
}

export class EventCreateModel implements IEventCreateModel {
    startDate: Date;
    endDate?: Date;
    title?: string;
    description?: string;

    constructor(data?: IEventCreateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startDate = data["startDate"] ? new Date(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>undefined;
            this.title = data["title"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): EventCreateModel {
        data = typeof data === 'object' ? data : {};
        let result = new EventCreateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        return data; 
    }
}

export interface IEventCreateModel {
    startDate: Date;
    endDate?: Date;
    title?: string;
    description?: string;
}

export class EventModel implements IEventModel {
    id: number;
    startDate: Date;
    endDate?: Date;
    title?: string;
    description?: string;

    constructor(data?: IEventModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.startDate = data["startDate"] ? new Date(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>undefined;
            this.title = data["title"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): EventModel {
        data = typeof data === 'object' ? data : {};
        let result = new EventModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        return data; 
    }
}

export interface IEventModel {
    id: number;
    startDate: Date;
    endDate?: Date;
    title?: string;
    description?: string;
}

export enum RegisterChildModelGender {
    Male = <any>"male", 
    Female = <any>"female", 
}

export enum RegisteredChildModelGender {
    Male = <any>"male", 
    Female = <any>"female", 
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}